function out=readFil(varargin)
%
% Output from the ABAQUS results file to MATLAB
%
% Syntax
%     #out#=readFil(#filFile#,#recordKeys#,#abqDir#)
%
% Description
%     This is the general function for the extraction of results from
%     Abaqus result files to Matlab.
%
% Input parameters
%     REQUIRED:
%     #filFile# (string) is a string containing the name of the ABAQUS
%         results file (*.fil in Abaqus/Standard or *.fin in
%         Abaqus/Explicit), along with its extension. The results file is
%         generated by Abaqus after the analysis has been completed.
%     #recordKeys# ([1 x m] or [m x 1]) is an integer row or column vector
%         which contains the record keys of the requested results. See the
%         documentation for the possible record keys and their types.
%     OPTIONAL:
%     #abqDir# (string) is a string containing the path of the current
%         working directory in which the results file exists.
%
% Output parameters
%     #out# ({1 x #m#} or {#m# x 1}) is a row or column cell array
%         containing in each cell the attributes of the corresponding
%         record key in #recordKeys#. If for one record key the results
%         file does not contain related output, the corresponding position
%         of #out# will be an empty array.
%
% Example
%     filFile='280.fil';
%     recordKeys=[101,102];
%     abqDir='C:\Abaqus_Temp';
%     out=readFil(filFile,recordKeys,abqDir)
%
% _________________________________________________________________________
% Abaqus2Matlab - www.abaqus2matlab.com
% Copyright (c) 2017 by George Papazafeiropoulos
%
% If using this toolbox for research or industrial purposes, please cite:
% G. Papazafeiropoulos, M. Muniz-Calvente, E. Martinez-Paneda.
% Abaqus2Matlab: a suitable tool for finite element post-processing.
% Advances in Engineering Software. Vol 105. March 2017. Pages 9-16. (2017)
% DOI:10.1016/j.advengsoft.2017.01.006



% Initial checks
if nargin<2
    error('Not enough input arguments.');
elseif nargin==2
    filFile=varargin{1};
    recordKeys=varargin{2};
    % Use the directory of this function
    abqDir=pwd;
else
    filFile=varargin{1};
    recordKeys=varargin{2};
    % Use the directory specified by the user
    abqDir=varargin{3};
    if nargin>3
        warning('Too many input arguments.')
    end
end
oldFolder=cd(abqDir);
% Check if recordKeys is a vector
if ~any(size(recordKeys)==1)
    warning('recordKeys is a matrix. It will be converted to a column vector.');
    recordKeys=recordKeys(:);
end
% Check if filFile exists in the working directory
if ~(exist(filFile,'file')==2)
    error(['The file ',filFile,' does not exist'])
end
% Read the data in the results file and convert it to an one row string
Rec=fil2Str(filFile);
% Scan all requested record keys
out=cell(size(recordKeys));
for i=1:length(recordKeys)
    recordKey=recordKeys(i);
    % Find the category of the record key
    cat=catRecKey(recordKey);
    switch cat
        case 'cat1'
            % Functions of category 1
            outi=readFilCat1(Rec,recordKey,zeros(1,0),zeros(1,0));
        case 'cat2'
            % Functions of category 2
            outi=readFilCat2(Rec,recordKey,zeros(1,0),zeros(1,0));
        case 'cat3'
            % Functions of category 3
            [outNum,outStr,m,k]=readFilCat3(Rec,recordKey,zeros(1,0),zeros(1,0),char(zeros(1,0)),zeros(1,0),zeros(1,0));
            if isempty(m)
                outi=cellstr(outStr);
            elseif isempty(k)
                outi=num2cell(outNum);
            else
                outi=[];
                j1=1;
                j2=1;
                for j=1:max([m,k/8])
                    if j1>length(m)
                        outi=[outi,cellstr(outStr(:,(j2-1)*8+1:j2*8))];
                        j2=j2+1;
                    elseif (m(j1)~=j)
                        outi=[outi,cellstr(outStr(:,(j2-1)*8+1:j2*8))];
                        j2=j2+1;
                    else
                        outi=[outi,num2cell(outNum(:,j1))];
                        j1=j1+1;
                    end
                end
            end
            % Individual rec functions not classified in categories
        case '1900'
            % Function for record key 1900
            [EleNum,EleType,EleNodes]=Rec1900(Rec,zeros(1,0),zeros(1,0));
            outi=[num2cell(EleNum),cellstr(EleType),num2cell(EleNodes)];
        case '1901'
            % Function for record key 1901
            outi=Rec1901(Rec,zeros(1,0),zeros(1,0));
        case '1902'
            % Function for record key 1902
            outi=Rec1902(Rec,zeros(1,0),zeros(1,0));
        case '1911'
            % Function for record key 1911
            [OutFlag,SetName,EleType]=Rec1911(Rec,zeros(1,0),zeros(1,0));
            outi=[num2cell(OutFlag),cellstr(SetName),cellstr(EleType)];
        case '1921'
            % Function for record key 1921
            [Release,Date,Time,NEleNode,EleLength]=Rec1921(Rec,zeros(1,0));
            outi=[cellstr(Release),cellstr(Date),cellstr(Time),...
                num2cell(NEleNode),num2cell(EleLength)];
        case '1940'
            % Function for record key 1940
            [EleNum,EleType]=Rec1940(Rec,zeros(1,0),zeros(1,0));
            outi=[num2cell(EleNum) cellstr(EleType)];
        case '1980'
            % Function for record key 1980
            outi=Rec1980(Rec,zeros(1,0),zeros(1,0));
        case '1991'
            % Function for record key 1991
            [EleOut1,NodeSetName,EleOut2,EleOut3]=Rec1991(Rec,zeros(1,0),zeros(1,0));
            outi=[num2cell(EleOut1),cellstr(NodeSetName),num2cell(EleOut2),...
                num2cell(EleOut3)];
        case '2000'
            % Function for record key 2000
            [incrOut,StepHeading]=Rec2000(Rec,zeros(1,0),zeros(1,0));
            outi=[num2cell(incrOut),cellstr(StepHeading)];
        otherwise
            outi=[];
    end
    out{i}=outi;
end
cd(oldFolder);
end

